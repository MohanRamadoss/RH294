Red Hat Certified Engineer (RHCE) EX294: Red Hat Ansible Automation, Third Edition by Sander van Vugt 
2020
RHEL 8

Lesson 01: Installing Ansible

1.1 Understanding Ansible

			CMS
		       ------

	    |				|
----------- |		ssh		|
| control | | ----------------------->	| 
----------- |				|Comp1
| Ansible | |		Playbook	|
----------- | ----------------------->	|
            |----------------------------
	    | ----------------------->	|Comp2
	    |				|--------------------------------
	    |		Playbook	|	Python			|
	    | ----------------------->	|----------------------->	|Comp3
	    | ----------------------->	|----------------------->	|Comp4


---------------------------------------------------------------------------------------------------------------------------------------------

1.2 Host Requirements 


	EPEL:					sudo      Comp1
	* ssh-keygen				ansible
	* USER
	* ansible				sudo	  Comp2
						python
	Control:				ansible
	* python
	* ansible
						sudo	  Comp3
		/etc/hosts IP-addr.

---------------------------------------------------------------------------------------------------------------------------------------------

1.3 Installing Ansible on the Control Node

Installing Ansible:
* Ansible can be installed from the repositories or using the Python pip installer
* In this procedure we'll discuss Python pip as well as the repositories method

Using Python pip to Install Ansible:
1. On control.example.com: yum install python3
2. yum -y install python3-pip
3. alternbatives --set python /usr/bin/python3
4. su -ansible; pip3 install ansible --user
5. ansible --version

Installing Ansible from the Repositories:
1. On the control node: use subscription-manager repos --list to verify the name of the latest avaliable repository
2. Use subscription-manager repos --enable=ansible-2-for-rhel-8-x86_64-rpms to enable the repository
3. Use yum install ansible to install the Ansible3 software
4. ansible --version to verify
5. On managed nodes: yum install python3

If using Centos8:
* On Centos 8, the Ansible software is expected to be avaliable from the EPEL repository
* Use yum install -y epel-release to make this repository avaliable
* Use yum install python3 ansible to install the ansible software

Setting up the Required Environment:
* After installing Ansible, you'll need to set up a dedicated Ansible user account:
1. On all nodes: useradd ansible
2. echo password | passwd --stdin ansibleyt
3. echo "ansible ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/ansible
4. On control.example.com: su - ansible; ssh-keygen
5. ssh-copy-id ansible1.example.com; ssh-copy-id ansible2.example.com


subscription-manager repos --list
subscription-manager repos --enable=ansible-2-for-rhel-8-x86_64-rpms
yum instrall -y ansible
ansible --version

---------------------------------------------------------------------------------------------------------------------------------------------

1.4 Preparing Managed Nodes

* Ansible needs a dedicated non-root user account with sudo privileges that can SSH into the managed nodes without entering a password 
* In this course we'll use an account with the name ansible to do so
* To set up this account, the following steps have already been completed:
	* useradd ansible
	* echo "password" | passwd --stdin ansible
	* echo "ansible ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/ansible

* On the control host, generate an SSH key and copy over to managed nodes:
	* ssh-keygen
	* ssh-copy-id ansible1.example.com	

* Install Python3
	* yum install python3
	* alternatives --set python /usr/bin/python3

---------------------------------------------------------------------------------------------------------------------------------------------

1.5 Verifying Ansible Installation

* As user ansible, type ansible --version
* Further verification is not possible yet, as additional settings need to be done

---------------------------------------------------------------------------------------------------------------------------------------------

Lesson 02: Setting up a Managed Environment 	

2.1 Setting up Static Inventory 

			DNS/
			/etc/hosts


			Inventory	------------> 	    dynamic
			* groups
			* variables	------------> 	    static

Managing Static Inventory:
* In a minimal form, a static inventory is a list of host names and IP addresses that can be managed by Ansible 
* Hosts can be grouped in inventory to make it easy to address multiple hosts at once 
* A host can be a member of multiple groups 
* Nested groups are also avaliable
* It is common to work with project-based inventory files
* Variables can be set from the inventory file - but this is deprecated practice
* Ranges can be used:
	* server[1:20] matches server1 up to server20
	* 192.168.[4:5].[0:255] matches two full class C subnets

Inventory File Locations 
* /etc/ansible/hosts is the dafault inventory
* Alternative inventory location can be specified through the ansible.cfg configuration file 
* Or use the -i inventory option to specify the location of the inventory file to use
* It is common practice to put the inventory file in the current project directory

Host Groups Usage:
* Functional host groups:	
	* web
	* lamp
* Regional host groups:
	* europa
	* africa
* Staging host groups:
	* test
	* development
	* production


mkdir install
cd install
vim inventory
ansible -i inventory all --list-hosts
ansible -i inventory ungrouped --list-hosts
ansible all --list-hosts

---------------------------------------------------------------------------------------------------------------------------------------------

2.2 Understanding Dynamic Inventory

* Dynamic inventory can be used to discover inventory in dynamic environments such as cloud 
* Many community-provided dynamic inventory scripts are avaliable
* These scripts are referred to in the same way as static inventory, but must have the execute permission set
* Alternatively, it's relatively easy to write your own dynamic inventory


ls
vim pascal.py

---------------------------------------------------------------------------------------------------------------------------------------------

2.3 Understanding Ansible Configuration Files

Understanding ansible.cfg
* Settings in ansible.cfg are organized in two sections 
	* [defaults] sets default settings
	* [privilege_escalation] specifies how Ansible runs commands on managed hosts

* The following settings are used:
	* inventory specifies the path to the inventory file
	* remote_user is the name of the user that logs in on the remote hosts
	* ask_pass specifies whether or not to prompt for a password 
	* become indicates if you want to automatically switch to the become_user
	* become_method sets how to become the other user 
	* become_user specifies the target remote user
	* become_ask_pass sets if a password should be asked for when escalating

Connecting to the Remote Hosts:
* The default protocol to connect to the remote host is SSH:
	* Key based authentication is the common approach, but password based authentication is possible as well
	* Use ssh-keygen to generate a public/private SSH key pair and next use ssh-copy-id to copy the public key over to the managed hosts

* Other connection methods are avaliable, to manage Windows for instance, use ansible_connection: winrm and set ansible_port:5986

Escalating Privileges:
* sudo is the default mechanism, su can also be used but is uncommon
* A password can be asked for, but it's common to do password-less escalation
* To setup password-less sudo, create a snapin file in /etc/sudoers.d/ with the following contents:
	* ansible ALL=(ALL) NOPASSWD:ALL
	
Understanding Localhost Connections:
* Ansible has an implicit localhost entry to run Ansible commands on the localhost
* When connecting to localhost, the default become settings are not used, but the account that ran the Ansible command is used
* Ensure this account has been configured with the appropriate sudo privileges

---------------------------------------------------------------------------------------------------------------------------------------------

2.4 Managing Ansible Configuration Files

Managing ansible.cfg:
* The ansible.cfg file is considered in order of precedence:
	* /etc/ansible/ansible.cfg
	* ~/.ansible.cfg if exists will overwrite the default
	* ./ansible.cfg is the configuration file in the current Ansible project directory and it will always have precedence if it exists

* Alternatively, if a variable ANSIBLE_CONFIG exists to refer to a specific config file, this will always have precedence
* Use ansible --version to find which configuration file currently is used


ansible --version
pwd
ls
cd ..
ls
ansible --version
ls -l /etc/anacrontab

---------------------------------------------------------------------------------------------------------------------------------------------

Lesson 03: Using Ad Hoc Commands 	

3.1 Using Ad Hoc Commands


  module  ----------->	ad hoc			
 --------	      -------------------       
		      |* ansible (this) |  -------->    Comp
		      |* ansible (that) |  -------->
		      -------------------      


			playbook
		      -------------
		      |* this	  | ---------> Comp
		      |* that     | ---------> Cloud 
		      |* also     |
		      -------------


Understanding Ad Hoc Commands:
* To run tasks on Ansible, you'll typically want to use Playbooks
* A Playbook is a YAML file in which tasks can be defined 
* For some tasks, writing a playbook is just too much work
* In such cases, you can use Ad hoc commands
* Ad hoc commands are also useful for testing if your playbook was successful

Ad Hoc Commands Ingredients:
* The basic structure is: ansible hosts -m module [-a 'module arguments'][-i inventory]
* The hosts part specifies on which host the command should be performed
* The module part indicates which Ansible module to use; following the module you'll specify module arguments
* If inventory is not specified, you'll need to specify the inventory as an argument
* An example of an ad hoc command is: ansible all -m user -a "name=lisa"
* And to verify the command works, use: ansible all -m command -a "id lisa" 

-------------------------------------------------------------------------------------------------------------------------------------------

3.2 Understanding Ansible Modules

* Ansible comes with lots of modules that allow you to perform specific tasks on managed hosts
* When using Ansible, you'll always use modules to tell Ansible what you want it to do, in ad-hoc commands as well as in playbooks
* Many modules are provided with Ansible, if required you can develop your own modules
* Use ansible-doc -l for a list of modules currently avaliable
* All modules work with arguments, ansible-doc will show which arguments are avaliable and which are required
* Ansible modules are idempotent: which means that when running them again they'll give the same result and if a task has already been configured, they won't do it again


ansible all -m user -a 'name=lisa state=absent'
ansible all -m command -a 'id lisa'
ansible all -m command -a 'id lisa'
ansible all -m ping 

-------------------------------------------------------------------------------------------------------------------------------------------

3.3 Using ansible-doc to get Module Documentation

Using ansible-doc:
* The ansible-doc command provides authoritative documentation about modules
* Use ansible-doc -l for a list of all modules
* Use ansible-doc modulename to get the documentation for a specific module

Understanding Module Status:
* Modules are very actively developed by the community, and the status field in the module documentation indicates the current status:
	* stableinterface: the module is stable and safe to use
	* preview: the module is in tech preview and its keywords may change
	* deprecated: the module should not be used anymore and will be removed in a future release
	* removed: the module has been removed and the documentation only still exists to help users migrating to its replacement

Understanding Module Support Status:
* The supported_by field in ansible-doc indicates who is responsible for supporting a module:
	* core: the module is supported by the core Ansible developers
	* curated: the primary support responsibility is with partners and companies in the community. Proposed changes are reviewed by the 			   core developers 
	* community: support is completely within the community


ansible-doc -l
ansible-doc -l | wc
ansible-doc user

-------------------------------------------------------------------------------------------------------------------------------------------

3.4 Introducing Essential Ansible Modules

Essential Ansible Modules:
* ping: verifies the ability to log in and that Python has been installed
	* ansible all -m ping
* service: checks if a service is currently running 
	* ansible all -m service -a "name=httpd state=started"
* command: runs any command, but not through a shell
	* ansible all -m command -a "/sbin/reboot -t now"
* shell: runs arbitrary commands through a shell
	* ansible all -m shell -a set
* raw: runs a command on a remote host without a need for Python 
* copy: copies a file to the managed host
	* ansible all -m copy -a 'content="hello world" dest=/etc/motd'


ansible all -m ping
ansible all -m service -a "name=httpd state=started"
vim inventory
ansible all -m service -a "name=sshd state=started"
ansible ansible2.example.com -m command -a "/sbin/reboot"
ansible all -m ping
ansible all -m shell -a set
ansible all -m copy -a 'content=hello world" dest=/etc/motd'
ansible all -m shell -a 'cat /etc/motd'

-------------------------------------------------------------------------------------------------------------------------------------------

Lesson 04: Getting Started with Playbooks 	

4.1 Using YAML to Write Playbooks

yaml:

------
-name
  ------
  task:
  -name:
  module:
     arg1
     arg2
  -name:
  ------
-name2
  ------
  task:
  -name:
  module
  	...

------ parameters


Why Playbooks?
* Ad-hoc commands can be used to run one or a few tasks
* Ad-hoc commands are convenient to test or when a complete managed infrastructure hasn't been set up yet
* Ansible Playbooks are used to run multiple tasks against managed hosts in a scripted way
* In Playbooks, one or multiple plays are started:
	* Each play runs one or more tasks 
	* In these tasks, different modules are used to perform the actual work
* Playbooks are written in YAML and have the .yml or .yaml extension

Understanding YAML:
* YAML is Yet Another Markup Language according to some
* According to others it stands for YAML Ain't Markup Language
* Anyway, it's an easy-to-read format to structure tasks/items that need to be created 
* In YAML files, items are using indentation with white spaces to indicate the structure of data
* Data elements at the same level should have the same indentation 
* Child items are indented more than the parent items
* There is no strict requirement about the amount of spaces that should be used, but 2 is common

Writing Your First Playbook

---
- name: deploy vsftpd
  hosts: ansible2.example.com
  tasks:
  - name: install vsftpd
    yum: name=vsftpd
  - name: enable vsftpd 
    service: name=vsftpd anabled=true
  - name: create readme file
    copy:
      content: "free downloads for everybody"
      dest: /var/ftp/pub/README
      force: no
      mode: 0444
...

Running Your First Playbook:
* Use ansible-playbook vsftpd.yml to run the playbook 
* Notice that a successful run requires the inventory and become parameters to be set correctly and also requires access to an inventory file
* The output of the ansible-playbook command will show what exactly has happened 
* Playbooks in general are idempotent, which means that running the same playbook again should lead to the same result
* Notice there is no easy way to undo changes made by a playbook


ansible-playbook vsftpd.yml

--------------------------------------------------------------------------------------------------------------------------------------------

4.2 Verifying Playbook Syntax 

Optimizing vim for YAML:
* In ~/.vimrc, include the following setting:
	* autocmd FileType yaml setlocal ai ts=2 sw=2 et

Verifying Playbook Syntax:
* ansible-playbook --syntax-check vsftpd.yml will perform a syntax check
* Use -v[vvv] to increase output verbosity:
	* -v will show task results
	* -vv will show task results and task configuration
	* -vvv also shows information about connections to managed hosts
	* -vvvv adds information about plug-ins, users used to run scripts and names of scripts that are executed
* Use the -C option to perform a dry run


ansible-playbook --syntax-check vsftpd-err.yml
vim vsftpd-err.yml
ansible-playbook -C vsftpd.yml
ansible-playbook -vvvv vsftpd.yml
ansible-playbook -vv vsftpd.yml
vim ~/.vimrcx 
+"autocmd FileType yaml setlocal ai ts=2 sw=2 et"
vim test.yaml 
+"
---
- name: mytest
  hosts: all
  task: 
  - name: task1"

--------------------------------------------------------------------------------------------------------------------------------------------

4.3 Writing Multiple-Play Playbooks

Understanding Plays:
* A play is a series of tasks that are executed against selected hosts from the inventory, using specific credentials 
* Using mulyiple plays allows running tasks on different hosts, using different credentials from the same playbook
* Within a play definition, escalation parameters can be defined:
	* remote_user: the name of the remote user
	* become: to enable or disable privilege escalation
	* become_method: to allow using an alternative escalation solution
	* become_user: the target user used for privilege escalation


vim web-setup-and-test.yml
ansible-playbook --syntax-check web-setup-and-test.yml
ansible-playbook -v web-setup-and-test.yml

--------------------------------------------------------------------------------------------------------------------------------------------

Lesson 05: Working with Variables and Facts 	

5.1 Understanding Variables


 FAST			Redhat 			Ubuntu			Playbook
------			variables		variables		variables
* mem						* inventory		static
* cpu's 					* include		* conditionals 
						* local fact		* package -{{webserver}}

Understanding Variables:
* A variable is a label that is assigned to a specific value to make it easy to refer to that value throughout the playbook
* Variables can be defined by administrators at different levels
* A fact is a special type of variable, that refers to a current state of an Ansible managed system 
* Variables are particularly useful when dealing with managed hosts where specifics are different:
	* Set a variable web_service on Ubuntu and Red Hat
	* Refer to the variable web_service instead of the specific service name  

---------------------------------------------------------------------------------------------------------------------------------------------

5.2 Using Variables 

Variables can be set at different levels
	* In a playbook
	* In inventory (deprecated)
	* In inclusion files

Variable names have some requirements
	* The name must start with a letter
	* Variable names can only contain letters, numbers and underscores

Defining Variables:
* Variables can be defined in a vars block in the beginning of a playbook

- hosts: all
  vars:
    web_package: httpd

* Alternatively, variables can be definded in a variable file, which will be included from the playbook

- hosts: all
  vars_files:
    - vars/users.yml

Using Variables:
* After defining the variables, it can be used later in the playbook
* Notice that order does matter!
* Refer to a variable as {{web_package}} 
* In conditional statements (discussed later), no curly braces are needed to refer to variable values:
	* when: "'not found' in command_result.err"
	* {% if ansible_facts['devices']['sdb'] is defined}
	     Secondary disk size: {{ansible_facts['devices']['sdb']['size']}}
* If the variable is the first element, using quotes is mandatory!

vim user.yml
ansible-playbook user.yml
ansible -m shell -a "grep lisa /etc/passwd"
ansible all -m shell -a "grep lisa /etc/passwd"

---------------------------------------------------------------------------------------------------------------------------------------------

5.3 Understanding Variable Precedence

Understanding Variable Scope:
* Variables can be set with different types of scope:
	* Global scope: this is when a variable is set from inventory or the command line
	* Play scope: this is applied when it is set from a play
	* Host scope: this is applied when set in inventory or using a host variable inclusion file
* When the same variable is set at different levels, the most specific level gets precedence.
* When a variable is set from the command line, it will overwrite anything else:
	* ansible-play book site.yml -e "web_package=apache"

Understanding Bulit-in Variables:
* Some variables are bulit in and cannot be used for anything else:
	* hostvars
	* inventory_hostname
	* inventory_hostname_short
	* groups
	* group_names
	* ansible_check_mode
	* ansible_play_batch
	* ansible_play_hosts
	* ansible_version

---------------------------------------------------------------------------------------------------------------------------------------------

5.4 Managing Host Variables

Using Host Variables:
* Variables can be assigned to hosts and to groups of hosts 
* The old way of doing so is through inventory, but this is now deprecated because it mixes two types of information in one file
* Instead, you should use directories to populate host and group variables


Defining Host Variables Through Inventory: 
* A variable can be assigned directly to a host:

[servers]
web1.example.com web_package=httpd

* Alternatively, variables can be set for host groups

[servers:vars]
web_package=httpd


Using Include Files:
* To define host and host group variables, directories should be created in the current project directory
* Use ~/myproject/host_vars/web1.example.com to include host specific variables
* Use ~/myproject/group_vars/webservers to include host group specific variables
* Notice that you don't have to define variables in these directories in the playbook, they are picked up automatically


sudo yum install -y tree
tree 
cat inventory
cat group_vars/lamp
vim site.yml
ansible-playbook site.yml
tree

---------------------------------------------------------------------------------------------------------------------------------------------

5.5 Using Multi-valued Variables

Understanding Array and Dictionary:
* Multi-valued variables can be used in playbooks
* When using a multi-valued variable, it can be written as an array (list), or as a dictionary (hash)
* Each of these has their own specific use cases 

Understanding Dictionary (Hash):
* Dictionaries can be written in two ways:
  users:
   linda:
    username:linda
    shell: /bin/bash
   lisa:
    username: lisa
    shell: /bin/sh

* Or as:
  users:
   linda:{ username: 'linda', shell:'/bin/bash'}
   lisa:{ username: 'lisa', shell:'/bin/bash'}

Using Dictionary:
* To address items in a dictionary, you can use two notations:
	* variable_name['key'], as in users['linda']['shell']
	* variable_name.key, as in users.linda.shell
* You cannot use loop or with_items on dictionaries

Using Array (list):
* Arrays provide a list of items, where each item can be addressed separately 
  users:
  -username:linda
   shell: /bin/bash
  -username: lisa
   shell: /bin/sh
* Individual items in the array can be addressed, using the {{ var_name[0] }} notation  
* To access all variables, you can use with_items or loop


cd arrays
ls
ls vars
cat vars/users-list
cat vars/users-dictionary
vim multi-list.yml
ansible-playbook multi-list.yml
vim multi-dictionary.yml
ansible-playbook multi-dictionary.yml
 
---------------------------------------------------------------------------------------------------------------------------------------------
5.6 Using Ansible Vault 

Dealing with Sensitive Data:
* Some modules require sensitive data to be processed
* This may include webkeys, passwords and more
* To process sensitive data in a secure way, Ansible Vault can be used
* Ansible Vault is used to encrypt and decrypt files

Creating an Encrypted File:
* To create an encrypted file, use: ansible-vault create playbook.yml
* This command will prompt for a new vault password and opens the file in vi for further editing 
* As an alternative for entering passwords on the prompt, a vault password file may be used, but you’ll have to make sure this file 
is protected in another way: ansible-vault create --vault-password-file=vault-pass playbook.yml
* To view a vault encrypted file, use: ansible-vault view playbook.yml
* To edit, use ansible-vault edit playbook.yml
* Use ansible-vault encrypt playbook.yml to encrypt an existing file and use: ansible-vault decrypt playbook.yml to decrypt it
* To change a password on an existing file use: ansible-vault rekey

Using Playbooks with Vault:
* To run a playbook that accesses Vault encrypted files, you need to use the -vault-id @prompt option to be prompted for a password
* Alternatively, you can store the password as a single-line string in a password file and access that using the: 
	--vault-password-file=vault-file option

Managing Vault Files:
* When setting up projects with Vault encrypted files, it makes sense to use separate files to store encrypted and non-encrypted variables
* To store host or host-group related variable files, you can use the following structure:
|-group_vars
|  |--dbservers
|    |-vars
|    |-vault

* This replaces the solution that was discussed earlier, where all variables are stored in a file with the name of the host or host group


vim create-user.yml
ansible-vault create secret.yml
cat secret.yml
ansible-playbook --ask-vault-pass create-user.yml
echo password > vault-pass
cat vault-pass
ls -l
chmod 600 vault-pass
ansible-playbook --vault-password-file=vault-pass create-user.yml

---------------------------------------------------------------------------------------------------------------------------------------------

5.7 Working with Facts

Understanding Ansible Facts:
* Ansible facts are variables that are automatically set and discovered by Ansible on managed hosts
* Facts contain information about hosts that can be used in conditionals
* For instance, before installing specific software you can check that a managed host runs a specific kernel version

Managing Fact Gathering:
* By default, all playbooks perform fact gathering before running the actual plays
* You can run fact gathering in an ad hoc command using the setup module 
* To show facts, use the debug module to print value of the ansible_facts variable
* Notice that in facts, a hierarchical relationship is shown where you can use the dotted format to refer to a specific fact 

Displaying Fact Names:
* In Ansible 2.4 and before, Ansible facts were stored as individual variables, such as: ansible_hostname and ansible_interfaces.
* In Ansible 2.5 and later, all facts are stored in one variable with the name ansible_facts and referring to specific facts happens 
in a different way: ansible_facts[‘host_name’] and ansible_facts[‘interfaces’]
* The old approach is referred to as “injecting facts as variables” and this behavior can be managed through the inject_facts_as_vars 
parameter

Turning off Fact Gathering:
* Disabling fact gathering may seriously speed up playbooks
* Use: gather_facts: no in the play header to disable
* Even if fact gathering is disabled, it can be enabled again by running the setup module in a task


ansible -m setup all
vim facts/facts.yml
ansible-playbook facts/facts.yml
vim facts/ipfact.yml
---------------------------------------------------------------------------------------------------------------------------------------------

5.8 Creating Custom Facts

Using Custom Facts:
* Custom facts allow administrators to dynamically generate variables which are stored as facts
* Custom facts are stored in an ini or json file in the /etc/ansible/facts.d directory on the managed host:
    * The name of these files must end in .fact
* Custom facts are stored in the ansible_facts.ansible_local variable
* Use: ansible hostname -m setup -a “filter=ansible_local” to display local facts
* Notice how fact filename and label are used in the fact

Custom Facts Example File:

[localfacts]
package = vsftpd
service = vsftpd
state = started


cd facts
cat newlocalfacts.yml
cat localfacts.fact
ansible-playbook newlocalfacts.yml
^A
ansible all -m setup -a “filter=ansible_local” 

---------------------------------------------------------------------------------------------------------------------------------------------

Lesson 06: Using Task Control 	

6.1 Using Loops and Items 

Understanding Loops:
* The loop keyword allows you to iterate through a simple list of items 
* Before Ansible 2.5, the items keyword was used instead 
- name: start some services
    service :
       name: “{{ item }}”
       state: started
    loop:
       - vsftpd
       - httpd

Using Variables to Define a Loop:
* The list that loop is using can be defined by a variable:
vars:
  my_services:
      - httpd
      - vsftpd
tasks:
  - name: start some services
  service:
      name:  “{{ item }}”
      state: started
  loop:  “{{ my_services }}”

Using Hashes/Dictionaries in Loops:
* Each item in a loop can be a hash/dictionary with multiple keys in each hash/dictionary

name:  create users using a loop
hosts: all
tasks:
- name: create users 
  user:
       name: “{{ item.name }}”
       state: present
       groups: “{{ item.groups }}”
  loop:
       - name: anna 
         groups: wheel
       - name: linda
         groups: users

Understand loops vs. items:
* The loop keyword is the current keyword
* In previous versions of Ansible, the: with_* keyword was used for the same purpose
* This syntax will probably be deprecated in future versions of Ansible:
    * with_items: equivalent to the loop keyword
    * with_file: the item contains a file, which contents is used to loop through
    * with_sequence: genereates a list of values based on a numeric sequence 


vim loopservices.yml
ansible-playbook loopservices.yml
vim inventory
ansible-playbook loopservices.yml
vim loopusers.yml
“- name: bob
    groups: users”
ansible-playbook loopusers.yml

---------------------------------------------------------------------------------------------------------------------------------------------

6.2 Using Register Variables with Loops 

Understanding register:
* A register is used to store the output of a command and address it as a variable
* You can next use the result of the command in a conditional or in a loop

vim register_loop.yml
ansible-playbook register_loop.yml
vim register_command.yml
ansible-playbook register_command.yml

---------------------------------------------------------------------------------------------------------------------------------------------

6.3 Using when to Run Tasks Conditionally

Using Conditions:
* when statements are used to run a task conditionally
* A condition can be used to run a task only if specific conditions are true
* Playbook variables, registered variables and facts can be used in conditions and make sure that tasks only run if specific conditions are true
* For instance, check if a task has run successfully, a certain amount of memory is avaliable, a file exist, etc.

Defining Simple Conditions:
* The simplest example of a condition is to check whether a Boolean variable is true or false
* You can also check and see if a non-Boolean variable has a value and use that value in the conditional
* Or use a conditional in which you compare teh value of a fact to the specific value of a variable

Examples: 

* ansible_machine == "x86_64"
* ansible_distribution_major_version == "8"
* ansible_memfree_mb == 1024
* ansible_memfree_mb <256
* ansible_memfree_mb >256
* ansible_memfree_mb <=256
* ansible_memfree_mb !=512
* my_variable is defined
* my_variable is not defined
* my_variable
* ansible_distribution is supported_distros


vim distro.yml
ansible-playbook distro.yml
" supported distros:
	- RedHat ->> Ubuntu
  tasks:
    name: nginx"

---------------------------------------------------------------------------------------------------------------------------------------------

6.4 Testing Multiple Conditions 

Testing Multiple Conditions:
* when can be used to test multiple conditions as well
* Use "and" or "or" and group the conditions with parentheses:
	* when: ansible_distribution == "CentOS" or
	  ansible_distribution == "RedHat"
	* when: ansible machine == "x86_64" and ansible_distribution == "CentOS"
* The when keyword also support a list and when using a list all of the conditions must be true
* Complex conditional statements can group conditions using parentheses

Combining Loops and Conditionals:
* Loops and conditionals can be combined 
* For instance, you can iterate through a list of dictionaries and apply the conditional statement only if a dictionary is found that matches the condition


vim when_multiple.yml
ansible-playbook when_multiple.yml
vim restart.yml
ansible-playbook -v restart.yml
ansible ansible2.example.com -m command -a "systemctl status crond"
ansible ansible2.example.com -m command -a "systemctl start crond"
ansinble-playbook restart.yml

---------------------------------------------------------------------------------------------------------------------------------------------

6.5 Using Handlers 

Understanding Handlers:
* Handlers allow you to configure playbooks in a way that one task will only run if another task has been running successfully
* In order to run the handler a notify statement is used from the main task to trigger tha handler
* Handlers typically are used to restart services or reboot hosts
* Handlers are executed after runningall tasks in a play
* Handlers will only run if a task has changed something, so if an ok result instead of a changed result is reported, the handler will not run
* If one of the tasks fails, tha handler will not run, but this may be overwritten using force_handlers: True
* One task may trigger more than one handler


vim handlers.yml
ansible-playbook handlers.yml

---------------------------------------------------------------------------------------------------------------------------------------------

6.6 Using Blocks

Understanding Ansible Blocks:
* A block is a logical group of tasks
* It can be used to control how tasks are executed
* One block can, for instance, be enabled using a single when
* Blocks can also be used in error condition handling 
	* Use block to define the main tasks to run
	* Use rescue to define tasks that run if tasks defined in the block fail
	* Use always to define tasks that will run, regardless of the success or failure of the block and rescue tasks
* Notice that items cannot be used on blocks


vim blocks.yml
ansible-playbook blocks.yml
vim blocks2.yml
ansible ansible2.example.com -m file -a "path=/var/www/html/index.html state=touch"
ansible-playbook blocks2.yml

---------------------------------------------------------------------------------------------------------------------------------------------

6.7 Dealing with Failures

Understanding Failure Handling:
* Ansible looks at the exit status of a task to determine whether it has failed 
* When any task fails, Ansible aborts that rest of the play on that host and continues with the next host
* Different solutions can be used to change that behavior
* Use ignore_errors in a task to ignore failures
* Use force_handlers to force a handler that has been triggered to run, even if (another) task fails

Defining Failure States:
* As Ansible only looks at the exit status of a failed task, it may think a task was successful where that is not the case
* To be more specific, use failed_when to specify what to look for in command output to recognize a failure

Using the fail Module:
* The failed_when keyword can be used in a task to identify when a task has failed
* The fail module can be used to print a message that informs why a task has failed 
* To use failed_when or fail, the result of the command must be registered and the registered variable output must be analyzed
* When using the fail module, the failing task must have ignore_errors set to yes


vim failure.yml
ansible-playbook failure.yml
vim failure2.yml
ansible-playbook failure2.yml

---------------------------------------------------------------------------------------------------------------------------------------------

6.8 Managing Changed Status

Handling Changed Status:
* Managing the changed status may be important, as handlers trigger on the changed status
* The result of a command can be registered and the registered variable can be scanned for specific text to determine that a change has occurred
* This allows Ansible to report a hanged status, where it normally would not, thus allowing handlers to be triggered
* Using changed_when is usable in two cases:
	* to allow handlers to run when a change would not normally trigger
	* to disable commands that run successful to report a changed status
	

vim changed.yml
ansible-playbook changed.yml

---------------------------------------------------------------------------------------------------------------------------------------------

Lesson 07: Deploying Files 	

7.1 Using Modules to Manipulate Files:

Common File Modules:
* Different Modules are avaliable for managing files:
	* lineinfile: ensures that a line is in a file, useful for changing a single line in a file
	* blockinline: manipulates multi-line blocks of text in files
	* copy: copies a file from a local or remote machine to a location on a managed host
	* fetch: used to fetch a file from a remote machine and store it on the management node
	* file: sets attributes to files and can also create and remove files, symbolic links and more
	

vim file.yml
ansible-doc file
ansible-doc stat
cd /tmp/ansible1.example.com

---------------------------------------------------------------------------------------------------------------------------------------------

7.2 Managing SELinux File Context

Managing SELinux Context:
* file: sets attributes to files, including SELinux context and can also create and remove files, symbolic links and more
* sefcontext: manages SELinux file context in the SELinux Policy (but not on files)
* Notice that file sets SELinux context directly on the file (like the chcon command) and not in the policy


vim selinux.yml
ansible-playbook selinux.yml
ansible all -m "ls -lZ /tmp/removeme"

---------------------------------------------------------------------------------------------------------------------------------------------

7.3 Using Jinja2 Templates

Understanding Jinja2 Templates:
* lineinfile and blockinline can be used to apply simple modifications to files
* For more advanced modifications,use Jinja2 templates
* While using templates,the target files are automatically customized using variables and facts
* In a Jinja2 template you will find muliple elements:
	* data
	* variables
	* expressions
	* control structures
* The variables in the template are replaced with their values when the Jinja2 template is rendered to the target file on the managed host
* If using variables, they can be specified using the vars section of the playbook

Avoiding Confusion When Using Templates:
* To prevent administrators from overwriting files that are managed by Ansible, set the ansible_managed string:
	* First, in ansible.cfg set ansible_managed = Ansible managed
	* On top of the Jinja2 template, set the {{ ansible_managed }} variable

vim vsftpd-template.yml
vim vsftpd-template.j2
ansible-playbook vsftpd-template.yml
ansible all -a "cat /etc/vsftpd.conf"

---------------------------------------------------------------------------------------------------------------------------------------------

7.4 Using Control Structures in Jinja2

Using Control Structures in Templates:
* In Jinja2 templates, control structures can be used to organize the template in an optimal way
* The for statement can be used to iterate through a variable and use all values in the variable
* The if statement can be used to have the template work with a variable if another variable is defined


vim hostfile.yml
vim templates/hosts.j2
ansible-playbook hostsfile.yml
ansible ansible2.example.com -m command -a "cat /etc/hosts"
vim inventory
ansible-playbook hostsfile.yml

---------------------------------------------------------------------------------------------------------------------------------------------

Lesson 08: Using Ansible Roles 	

8.1 Understanding Directory Structure Best Practices 

~/myproject/ansible.cfg
			inventory-dev
			inventory-prod
			site.yml
			lamp.yml ------------------> * ~/.ansible/roles/nginx
						     * ~/.ansible/roles/httpd				
			file.yml ------------------> * ~/.ansible/roles/samba
						     * ~/.ansible/roles/nfs
			group-vars/lamp
					  /file
			host_vars
			
Organizing Ansible Contents:
* When working with Ansible, it's recommended to use project directories so that contents can be organized in a consistent way
* Each project directory may have its own ansible.cfg, inventory as well as playbooks 
* If the directory grows bigger, variable files and other include files may be used
* And finally, roles can be use to standardize and easily re-use specific parts of Ansible
* For now, consider a role a complete project dedicated to a specific task that is going to be included in the main playbook

Directory Layout Best Practices:
* Ansible Documentation describes best practices
  (https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html)
  
* Some highlights:
	* On top in the directory, use site.yml as the master playbook
	* From site.yml, call specific playbooks for specifictypes of host (webservers.yml, dbservers.yml, etc.)
	* Consider using different inventory files to differentiate between production and staging phases 
	* Use groups_var/ and host_vars/ to set host related variables
	* Use roles to standardize common tasks
	
---------------------------------------------------------------------------------------------------------------------------------------------
 
8.2 Understanding Ansible Roles

Understanding Roles:
* Ansible Playbooks can be very similar: code used in one playbook can be useful in other playbooks also
* To make it easy to re-use code, roles can be used. A role is a collection of tasks, variables, files, templates and other resources 
in a fixed directory structure that, as such, can easily be included from a playbook
* Roles should be written in a generic way , such that play specific can be defined as variables in the play and overwrite the dafault 
variables that should be set in the role

Understanding Roles Default Structure:
* defaults contains default values of role variables. If variables are set at the play level as well, these default values are overwritten
* files my contain static files that are needed from the role tasks
* handlers has a main.yml taht defines handlers used in the role
* meta has a main.yml that may be used to include role metadata, such as information about author, license, dependencies and more
* tasks contains a main.yml that defines the role task definitions
* templates is used to store Jinja2 templates
* tests may contain an optional inventory file, as well as a test.yml playbook that can be used to test the role
* vars may contain a main.yml with standard variables for the role (which are not meant to be overwritten by playbook variables)

Understanding Role Variables:
* Variables can be defined at different levels in a role
* vars/main.yml has the role default variables, which are used in default role functioning. They are not intended to be overwritten 
* defaults/main.yml can contain dafault variables. These have a low precedence and can be overwritten by variables with the same name 
that are set in the playbook and which have higher precedence
* Playbook variables will always overwrite the variables as set in the role. Site-specific variables such as secrets and vault encrypted 
data should always be managed from the playbook, as role variables are intended to be generic
* Role variables are defined in the playbook when calling the role and they have the highest precedence and overwrite playbook variables 
as well as inventory variables

Understanding Role Location:
* Roles can be obtained in many ways:
	* You can write your own roles
	* For Red Hat Enterprise Linux, the rhel-system-roles package is avaliable
	* The community provides roles through the Ansible Galaxy website
* Roles can be stored at a default location and from there can easily be used from playbooks:
	* ./roles has highest precedence
	* ~/.ansible/roles is checked after that
	* /etc/ansible/roles is checked next
	* /usr/share/ansible/roles is checked last


Using Roles in a Playbook:
* Roles are reffered to from playbooks
* When roles are used, they will run before any task that is defined in the playbook 

---
- name: role demo
  hosts: all
  roles: 
    - role1
	- role2
	
* When calling a role, role variables can be defined

---
- name: role variable demo
  hosts: all
  roles: 
    - role: role1
	- role: role2
	  var1: cow
	  var2: goat
	  
---------------------------------------------------------------------------------------------------------------------------------------------

8.3 Using Ansible Galaxy for Standard Roles

Using Ansible Galaxy:
* Administrators can define their own roles or standard roles can be used from Ansible Galaxy
* Ansible Galaxy is a public website where community provided roles are offered 
* Before writing your own roles, check Galaxy, you may get the roles from there
* An easy-to-use search interface is avaliable at galaxy.ansible.com


ansible-galaxy install geerlingguy.nginx
vim main.yml
cd geerlingguy.nginx
cd geerlingguy.nginx/tasks
vim setup-RedHat.yml
vim nginx-role.yml
ansible-playbook nginx-role.yml

---------------------------------------------------------------------------------------------------------------------------------------------

8.4 Using the Ansible Galaxy Command Line Tool

Using the Galaxy CLI Utility:
* ansible-galaxy serach: will search for roles
	* If an argument is provided, ansible-galaxy will serach for this argument in the role description
	* Use options --author, --platforms and --galaxy-tags to narrow down the search results
	* ansible-galaxy search 'wordpress' --platforms EL

* ansible-galaxy info: provides information about roles 
	* ansible-galaxy info bertvv.wordpress

* ansible-galaxy install: downloads a role and installs it in ~/.ansible/roles
* After download, these roles can be used in playbooks, like any other role

Managing Roles:
* ansible-galaxy list: shows installed roles
* ansible-galaxy remove: can be used to clean up and remove roles
* ansible-galaxy init creates a directory structure that can be used to start developing your own role:
	* It interacts with the Ansible Galaxy website API
	* Specify username and role name as arguments 
	* ansible-galaxy init user.myrole
	
Using a Requirements File:
* ansible-galaxy: can be used to install a list of roles based on definitions in a requirements file
* A requirements file is a yml file that defines a list of required roles that are specified using the src keyword
* The src keyword can contain the name of a role from Ansible Galaxy, or a URL to a custom location pointing to your own roles
* Create roles/requirements.yml in the projects directory to use it
* Always specify the optional version attribute, to avoid getting surprises when a newer version of a role has become avaliable.
- src: file:///opt/local/roles/myrole.tar
  name: myrole
  version: 1.0
* To install roles using a requirements file, use: ansible-galaxy install -r roles/requirements.yml
  

ansible-galaxy search 'wordpress' --platforms EL
ansible-galaxy info bertvv.wordpress
ansible-galaxy install bertvv.wordpress
vim wordpress.yml

vim roles/requirements.yml
ansible-galaxy install -r roles/requirements.yml -p roles
vim roles/requirements.yml
-> "- version: 2.7.0
    - name: nginx-2.7.0"
ansible-galaxy install -r roles/requirements.yml -p roles

---------------------------------------------------------------------------------------------------------------------------------------------
	
8.5 Creating Custom Roles

Creating Roles:
* To create your own roles, use ansible-galaxy init myrole to create the role directory structure
* Mind the location of the directory structure, you can put it in the local project directory, or in a directory that is accesible 
  for all projects
* Populate the required role files as discussed before

Creating Roles - Best Practices:
* Each role should have its own version control repository 
* Don't put sensitive information in the role, but in the local plybooks or Ansible Vault instead 
* Use ansible-galaxy init to create the role structure 
* Don't forget to edit the README.md and the meta/main.yml to contain documentation about your role
* Roles should be dedicated to one task/function. Use multiple roles to manage multiple tasks/functions.
* Have a look at existing (Galaxy) roles before starting to write your own

Defining Role Dependencies:
* The meta/main.yml can be used to define role dependencies
* Dependencies listed here will be installed automatically when this role is used 

Using Conditional Roles:
* Conditional roles call a role dynamically, using the include_role module 
	* This makes it so conditional roles are treated more as tasks 
* Conditional Roles can be combined with conditional statements:
	* This makes it so a role will only run if the conditional statement is true 
	* Use include_role in a task statement to do so
	
---
- hosts: lamp
  tasks:
  - include_role: 
      name: lamp
    when: "ansible_facts['os_family'] == 'RedHat'"
    

cd roles
ls
tree motd
cd motd
vim tasks/main.yml
vim templetes/motd.j2
vim defaults/main.yml
vim vars/main.yml
vim handlers/main.yml
rm -rf handlers/ vars/
tree
rm -rf tests/
vim meta/main.yml
vim README.md
cd .. / .. 
ls
vim motd-role.yml
ansible-playbook motd-role.yml
ansible ansible2.example.com -m shell -a 'cat /etc/motd'

---------------------------------------------------------------------------------------------------------------------------------------------

8.6 Managing Order of Execution 

Understanding Role Order of Execution:
* Role tasks are always executed before playbook tasks
* Next, playbook tasks are executed 
* And after playbook tasks, handlers are executed
* Use: pre_tasks to define playbook tasks that are to be executed before the tasks in a role:
	* If these tasks notify a handler, this handler is executed before as well
* The post_tasks keyword can be used to define playbook tasks that are executed after playbook tasks and roles


vim pretasks.yml
ansible-playbook pretasks.yml

---------------------------------------------------------------------------------------------------------------------------------------------

8.7 Understanding RHEL System Roles

* The rhel-system-roles package can be installed to provide some standard roles for RHEL 6.10 and later
* These roles are based on the community linux-system-roles and supported by Red Hat support 
* Use the rhel-system-roles to overcome the difference between configuration choices on RHEL 6,7, and 8

---------------------------------------------------------------------------------------------------------------------------------------------

Lesson 09: Using RHEL System Roles 	

9.1 Understanding RHEL System Roles

* RHEL system roles are provided to configure standard RHEL operations 
* RHEL system roles have been provided since RHEL 7.4, and can be used to configure RHEL 6.10 and later
* Install the rhel-system-roles package to use them
* RHEL system roles are derived from the Ansible Linux System Roles project, which is avaliable through Ansible Galaxy

Current RHEL System Roles:
* Currently, the following RHEL system roles are provided:
      * rhel-system-roles.kdump configurates the kdump crash recovery service 
      * rhel-system-roles.network configurates network interfaces
      * rhel-system-roles.selinux manages all aspects of SELinux
      * rhel-system-roles.timesync is used to set up Network Time Protocol or Precision Time Protocol
      * rhel-system-roles.postfix is used to configurate a host as a Postfix MTA
      * rhel-system-roles.firewall configurates a firewall
      * rhel-system-roles.tuned configurates the tuned service 
* Addiotional RHEL system roles are likely to be introduced

---------------------------------------------------------------------------------------------------------------------------------------------

9.2 Installing RHEL System Roles

* Use: yum install rhel-system-roles to install them 
* The roles are installed to the /usr/share/ansible/roles directory, notice that the upstream linux-system-roles name is provided 
  as a symbolic link to provide maximum compatibility
* Documentation of Ansible system roles is avaliable in /usr/share/doc/rhel-system-roles-<version>
* Look for example YAML files in the role directories


su -
yum search rhel-system-roles
yum install -y rhel-system-roles
rpm -ql rhel-system-roles
cd /usr/share/ansible/roles
ls
cd rhel-system-roles.selinux/
ls
tree

---------------------------------------------------------------------------------------------------------------------------------------------

9.3 Using the RHEL SELinux System Role

The RHEL system role for SELinux can do several things:
* Set enforcing or permissive mode
* Set SELinux file contexts 
* Run restorecon

Rebooting After Making Changes:
* In some cases, to apply SELinux changes (such as a switch between enabled and disabled mode), a reboot is required
* The SELinux role doesn't reboot hosts itself because it should be up to the administrator to do that
* The role will set the selinux_reboot_required variable to true, and fail if a reboot is required
* This is used in a block / rescue structure, where the play is failing if the variable is not set to true 
* If the variable is set to true, the host is rebooted and the role is started again 
* See sample code in example-selinux-playbook in the roles documentation

Setting SELinux Related Variables:
* To Configure SELinux from the role, set at least the following variables:
	* selinux_state
	* selinux_booleans
	* selinux_fcontexts
	* selinux_restore_dirs
	* selinux_ports
	
	
cd /usr/share/doc/rhel-system-roles/selinux
ls
less README.md
vim example-selinux-playbook.yml
cd /usr/share/ansible/
ls
cd roles
ls
cd rhel-system-roles.selinux/
tree
vim tasks/main.yml

---------------------------------------------------------------------------------------------------------------------------------------------

9.4 Using the RHEL TimeSync System Role 

Why Does it Make Sense?
* rhel-system-roles.timesync can be used to manage time synchronization
* As the timesync service is different between RHEL 6 and RHEL 7/8, it makes sense managing this functionality using a rhel-system-role

Using rhel-system-roles.timesync:
* The role itself is configured to work with different variables, of which timesync_ntp_servers is the most important one
* Items in this variable are made up of different attributes, of which two are common:
	* hostname: shows the hostname of the time server
	* iburst: specifies that fast iburst synchronization should be used
* The timezone variable is also important, and sets the current timezone to be used
* A default playbook is avaliable in /usr/share/doc/rhel-system-roles/timesync


vim /usr/share/doc/rhel-system-roles/timesync
vim /usr/share/doc/rhel-system-roles/timesync/example-timesync-playbook.yml
vim setuptime.yml
vim setuptime-light.yml
vim group_vars/servers/timesync.yml
vim inventory
ansible-playbook setupline-light.yml

---------------------------------------------------------------------------------------------------------------------------------------------

Lesson 10: Using Ansible in Large Environments 	

10.1 Managing Inventory

Understanding Inventory Options:
* A static inventory file can be used as a list of managed hosts
* Dynamic inventory can automatically discover hosts, by talking to an external host management system, such as FreeIPA, Active Directory, 
  Red Hat Satelite and more
* Also, multiple inventories can be used, for instance by putting multiple inventory files in a directory and use that as the source 
  of inventory

Managing Dynamic Inventory:
* Dynamic inventory scripts are avaliable for different environments
	* Check https://github.com/ansible/ansible/tree/devel/contrib/inventory
* They are used like static inventory files, through ansible.cfg, or using the -i option to the ansible[-playbook] command
* Instead of using community dynamic inventory scripts, you can also write your own

Writing Dynamic Inventory Scripts:
* The only requirement is that the script returns the inventory information in JSON format 
* To see the correct output format, use ansible-inventory --list on any inventory
* Scripts can be written in any language, but Python is common

Using Multiple Inventory Files:
* If the inventory specified is a directory, all inventory files in that directory are considered
* This includes as well as dynamic inventory
* Inventory files cannot be created with dependencies to other inventory files


ansible-inventory --list
vim pascal.py
./pascal.py --list

----------------------------------------------------------------------------------------------------------------------------------------------

10.2 Addressing Host Patterns 

Addressing Hosts:
* By default, hosts are addressed with their host name as specified in inventory
* IP addresses can also be used
* Host groups are common and are defined in inventory:
	* Group: all is implicit and doesn't have to be defined
	* Group: ungrouped is also implicit and addresses all hosts that are not members of a group
* If special characters are used, always put them between quotes to avoid the special character being interpreted by the shell

Addressing Hosts Wildcard Examples:
* -hosts: '*.example.com'
* -hosts: '192.168.*'
* -hosts: 'web*'
* -hosts: web1,db1,192.168.4.2
* -hosts: web,&eastcoast
* -hosts: web,!web1
* -hosts: all,!web

----------------------------------------------------------------------------------------------------------------------------------------------

10.3 Configuring Parallelism

Understanding Processing Order:
* Plays are executed in order on all hosts referred to, and normally Ansible will start the next task if this task successfully completed on all managed hosts
* Ansible can run on multiple managed hosts simultaneously, but by default the maximum number of simultaneous hosts is limited to five 
* Set forks=n in ansible.cfg to change the maximum number of simultaneous hosts
* Alternatively, use -f nn to specify the max number of forks as argument to the ansible[-playbook] command
* The dafault of 5 is very limited, so you can set this parameter much higher, in particular if most of the work is done on the managed hosts and not on the control mode

Managing Rolling Updates:
* The dafault behaviour of running one task on all hosts, and next proceed to the next task means that in cluster environments you may have all hosts temporarily being unavaliable
* Use the serial keyword in the playbook to run hosts through the entire play in batches

----------------------------------------------------------------------------------------------------------------------------------------------

10.4 Organizing Directory Structure

Understanding Inclusion:
* If playbooks grow larger, it is common to use modularity by using includes and imports
* Includes and imports can happen for playbooks as well as tasks 
* An include is a dynamic process; Ansible processes the contents of the included files at the moment that this import is reached 
* An import is a static process; Ansible preprocesses the imported file contents before teh actual play is started
	* Playbook imports must be defined at the beginning of the playbook, using: import_playbook
	
Including Tasks Files:
* A task file is a flat list of tasks
* Use: import_tasks to statically import a task file in the playbook, it will be included at the location where it is imported
* Use: include_tasks to dynamically include a task file
* Dynamically including tasks means that some features are not avaliable:
	* ansible-playbook --list-tasks will not show teh tasks
	* ansible-playbook --start-at-task doesn't work
	* You cannot trigger a handler in an imported task file from the main task file
* Best practice: store task files in a dedicated directory to make management easier 

When to Include Task Files:
* When modularity is required, for instance to differentiate between groups of tasks that need to be executed against specific host types
* When different groups of IT staff are responsible for different setup tasks 
* If a task needs to be executed only in specific cases

Using Variables for External Plays and Tasks:
* In the design, it is recommended to keep include files as generic as possible 
* Define variables independently from the playbook
	* in separate include files
	* using group_vars and host_vars
	* or using local facts
* This allows you to process different values on different groups of hosts, while still using the same playbook


vim includes.yml
vim install-and-setup.yml
ansible-playbook includes.yml

----------------------------------------------------------------------------------------------------------------------------------------------

Lesson 11: Troubleshooting Ansible 	

11.1 Managing Ansible Logs

Understanding Ansible Logging:
* By default Ansible is not configured to log its output anywhere 
* Set log_path in ansible.cfg to write logs to a specific destination
	* Create this file in the project directory, /var/log is not writable by the Ansible user and will only work when running the playbook 
          with sudo
* When using this, you should also use log rotation


vim ansible.cfg // "[defaults] ... " + "log_path = lesson11.log"
ansible-playbook vsftpd.yml
ls
less lesson11.log
ansible-playbook --syntax-check vsftpd.yml
vim vsftpd.yml

----------------------------------------------------------------------------------------------------------------------------------------------

11.2 Using the Debug Module

* Variables play an important role in playbooks
* The debug module is used to show values of variables in playbooks
* It can also be used to show messages in specific error situations 


ansible-doc debug
vim debugme.yml
ansible-playbook debugme.yml
ansible-playbook -v debugme.yml

----------------------------------------------------------------------------------------------------------------------------------------------

11.3 Using Check Mode

* Use ansible-playbook --check on a playbook to perform check mode; this will show what would happen when running the playbook without 
  actually changing anything 
	* Modules in the playbook must support check mode
	* Check mode doesn't always work well in conditionals
	
* Set: check_mode: yes within a task to always run that specific task in check mode
	* This is useful for checking individual tasks
	* When setting: check_mode: no, for a task, this task will never run in check mode
	* Notice that: check_mode: no, is new since Ansible 2.6, and replaces the: always_run: yes, option from earlier versions 

Using Check Mode on Templates:
* Add --diff to an Ansible playbook run to see differences that would be made by template files on a managed hosts
		* ansible-playbook --check --diff myplaybook.yml
		

ansible-playbook --check vsftpd.yml

----------------------------------------------------------------------------------------------------------------------------------------------

11.4 Using Modules for Troubleshooting and Testing 

Understanding Modules to Check:
* uri: checks content that is returned from a specific URL
* script: runs a script from the control node on the managed hosts
* stat: checks the status of files; use it to register a variable and next test to determine if a file exists
* assert: this module will fail with an error if a specific condition is not met

Understanding stat:
* The: stat module can be used to check on file status
* It returns a dictionary that contains a stat field which can have multiple values:
	* atime: last access time of the file
	* isdir: true if file is a directory
	* exists: true if file exists
	* size: size in bytes
	* and many more
	

vim bashversion.yml
ansible-playbook bashversion.yml
vim assertstat.yml
ansible-playbook assertstat.yml

----------------------------------------------------------------------------------------------------------------------------------------------

11.5 Troubleshooting Connection Issues

Understanding Connection Issues:
* Connection issues include the following 
	* Issues setting up the physical connection
	* Issues running tasks as teh target user

Analyzing Authentication Issues:
* Confirm the: remote_user setting and existence of remote user on the managed host
* Confirm host key setup
* Verify: become and become_user
* Check that sudo is configured correctly 

Connecting to Managed Hosts:
* When a host is avaliable at different IP addresses / names, you can use ansible_host in inventory to specify how to connect
* The ensures that the connection is made in a persistent way, using the right interface
* web.example.com ansible_host=192.168.4.100

Using Ad Hoc Commands to Test Connectivity:
* The ping module was developed to test connectivity
* Use the --become option to also test privilege escalation
	* ansible ansible1 -m ping
	* ansible ansible1 -m ping --become
* Use the command module to test different items:
	* ansible ansible1 -m command -a 'df'
	* ansible ansible1 -m command -a 'free -m'
	
	
ansible ansible1.example.com -m ping
ansible ansible1.example.com -m ping --become 
ansible all -m command -a 'df'
ansible all -m command -a 'free -m'
ansible all -m command -a 'df | grep sda' //failed
ansible all -m shell -a 'df | grep sda' //failed
ansible all -m shell -a 'df' 
ansible all -m shell -a 'df | grep nvme' 

----------------------------------------------------------------------------------------------------------------------------------------------

11.6 Analyzing Playbook Errors

Analyzing Playbooks:
* Start by reading output messages 
* Next, add verbosity using -v:
	* -v: the output data is displayed
	* -vv: output as well as input data is shown
	* -vvv: adds connection information
	* -vvvv: adds additional information, for instance, about scripts that are executed and the user who's running tasks
	
----------------------------------------------------------------------------------------------------------------------------------------------

11.7 Avoiding Errors in Playbook Best Practices

Best Practices:
* When developing Playbooks, some best practices should be applied 
* The: name of plays and tasks should make sense to clearly see what's happening 
* Include comments to clarify difficult bits
* Use white spaces to make playbooks mor readable
* Indentation is essential
* Keep playbooks simple and small
* Use includes when playbooks risk getting too big

----------------------------------------------------------------------------------------------------------------------------------------------

Lesson 12: Managing Software with Ansible 	

12.1 Understanding Modules Related to Software Management 

Understanding Software Management Tasks:
* To manage software on RHEL systems, different tasks need to be managed
* Systems need to be subscribed 
* Repositories and software channels need to be configured
* Software needs to be installed and removed

Understanding Software Management Modules:
* package: Distribution agnostic module to manage packages
* win_package: Manages packages on Windows
* apt: Manages packages on Ubuntu
* yum: Manages packages on RHEL
* yum_repository: Manages Yum repositories
* package_facts: Returns information about packages as facts
* rpm_key: Adds or removes GPG keys from an RPM package database
* redhat_subscription: Uses the subscription_manager command to manage subscriptions
* rhn_register: Managed Red Hat Network registration using: rhnreg_ks
* rhn_channel: Manages RHN Channel subscription
* Other modules are avaliable, see
 https://docs.ansible.com/ansible/latest/modules/list_of_packaging_modules.html for more information
 
----------------------------------------------------------------------------------------------------------------------------------------------

12.2 Implementing a Playbook to Manage Software


vim sw_mgmt_demo.yml
ansible-playbook sw_mgmt_demo.yml
ansible ansible2.example.com -a "cat /etc/yum.repos.d/lesson12" //failed
ansible ansible2.example.com -a "ls /etc/yum.repos.d/"
ansible ansible2.example.com -a "cat /etc/yum.repos.d/lesson12.repo" //ok

----------------------------------------------------------------------------------------------------------------------------------------------

Lesson 13: Managing Users 	

13.1 Understanding Modules Related to User Management

Modules Related to User Management:
* user: Manages Users and their common properties
* group: Manages Groups and their common properties 
* pamd: Configures PAM
* authorized_key: Copies SSH public keys from Ansible
* lineinfile: Modifies configuration files based on regex

Understanding authorized_key:
* The authorized_key module can be used to copy a user public key to the ~/.ssh/authorized_keys file
* This is useful to enable SSH access from remote machines, such as the Ansible control node
* Note that this will only copy the public key, and does NOT generate any SSH keys
* To generate SSH keys for new users, use the user module and its option: generate_ssh_key 

----------------------------------------------------------------------------------------------------------------------------------------------

13.2 Implementing a Playbook to Manage Users

Managing Users:
* Some tasks have well defined modules, some tasks don't
* When no specific module exists, it comes down to your own creativity
* When creating users, you'll at least want to use the users and groups modules, whereas authorized_key is useful as well

Managing sudo:
* There is no Ansible module for managing sudo
* Using templates and variables, it's not too difficult to set it up manually through


vim setup_users.yml
cat vars/users
cat vars/groups

vim vars/defaults
vim sudoers.j2
vim setup_sudo.yml
ansible-playbook setup_sudo.yml

----------------------------------------------------------------------------------------------------------------------------------------------

13.3 Managing Encrypted Passwords

Understanding Encrypted Passwords:
* Encrypted user passwords are stored in /etc/shadow
* A password strings look like:
  $6$23879879879/$927395798793847t982798789237
* This string consists of 3 parts:
	* The hashing algorithm that is used
	* The random salt that was used to encrypt the password
	* The encrypted hash of the user password
* To create an encrypted password, a random salt is used to ensure that two users that have identical passwords would not have identical 
  entries in /etc/shadow
* This salt and the unencrypted password are combined and encrypted, which generates the encrypted hash that is stored in /etc/shadow

Creating Encrypted Passwords in Ansible:
* The Ansible user module does not generate encrypted passwords
* To generate an encrypted password, an external utility must be used to generate a cryptostring
* Next, the cryptostring can be used in a variable to create the user password
* For enhanced security, consider storing the password hash in a vault encrypted file


ansible localhost -m debug -a "msg={{ 'password' | password_hash('sha152','mypassword') }}"
vim userpw.yml
ansible-playbook userpw.yml
ansible ansible2.example.com -m user "name=anna state=absent remove=yes"
ansible ansible2.example.com -m user -a "name=anna state=absent remove=yes"
ansible-playbook userpw.yml
ssh anna@ansible2
exit

----------------------------------------------------------------------------------------------------------------------------------------------

Lesson 14: Managing Processes and Tasks 	

14.1 Understanding Modules for Managing Processes and Tasks

Modules for Managing Processes and Tasks:
* cron: Uses cron to schedule a job
* at: Uses at to run a future job
* file: Because some tasks simply don't have a specific Ansibe module
* service: Manages Services
* service_facts: Uses information about services as facts
* systemd: Manages Systemd Services

Understanding the cron Module:
* The cron module has a name option, which is useful to uniquely identify entries in crontab
* Notice that this option has no meaning for Cron, but it helps Ansible in managing crontab entries

----------------------------------------------------------------------------------------------------------------------------------------------

14.2 Implementing a Playbook to Manage Processes and Tasks

vim setup_crontab.yml
cat inventory
ansible-playbook setup-crontab.yml
ansible ansible2.example.com -a "ls /etc/cron.d"
ansible ansible2.example.com -a "cat /etc/cron.d/keep-alive-messages"
vim delete-cron-job.yml
ansible-playbook delete-cron-job.yml
vim setup-crontab.yml
vim delete-cron-job.yml
ansible-playbook delete-cron-job.yml
vim setup-at-task.yml
ansible-playbook setup-at-task.yml
ansible ansible2.example.com -a "which at" //failed
ansible-doc yum
ansible ansible2.example.com -m yum -a "name=at state=present"
ansible-playbook setup-at-task.yml
ansible ansible1.example.com -m yum -a "name=at state=present"
vim setup-boot-target.yml
ansible-playbook setup-boot-target.yml -v

----------------------------------------------------------------------------------------------------------------------------------------------

Lesson 15: Managing Storage 	

15.1 Understanding Modules for Managing Storage

* parted: runs the parted utility
* lvg: create LVM volume group
* lvol: creates LVM logical volumes
* filesystem: managed filesystems
* mount: manages mounts
* vdo: manages VDO storage

----------------------------------------------------------------------------------------------------------------------------------------------

15.2 Implementing a Playbook to Manage Storage

vim setup-storage.yml
cat vars/storage.yml
vim setup-storage.yml
ansible-playbook setup-storage.yml

----------------------------------------------------------------------------------------------------------------------------------------------

Lesson 16: Managing Networking
	
16.1 Using Network Roles for Network Management

Using the Network System Role:
* RHEL8 includes a RHEL system role to manage networking
* Use ansible-galaxy list for an overview of all RHEL8 system roles
* See contents of the roles in /usr/share/ansible/roles

Setting Variables in the RHEL8 System Roles:
* Two variables are used to configure the network role:
	* network_provider: typically set to nm
	* network_connection: specifies details about the network connection
* Defaults for these variables are set in /usr/share/ansible/roles/rhel-system-roles.network


cd /usr/share/ansible/roles
ls
cd rhel-system-roles.network/
ls
cd tasks/
ls
vim main.yml
cd /usr/share/doc/rhel-system-roles/network
ls
vim example-bond-with-vlan-playbook.yml
cd ~/rhce8/lesson16/
ls
vim setupnw.yml
vim networkvars.yml
ansible-playbook setupnw.yml //failed
vim setupnw.yml
ansible-playbook -C setupnw.yml 

----------------------------------------------------------------------------------------------------------------------------------------------

16.2 Understanding Modules for Network Management

Understanding Modules:
* Different modules are avaliable for managing network settings
* nmcli: is used to manage many parameters for network devices or connections
* hostname: can be used to set the name of a managed host
* firewalld: can be used to manage Firewalld rules


ansible all -m setup -a 'gather_subset=network filter=ansible_interfaces'
ansible all -m setup -a 'gather_subset=network filter=ansible_ens224'
vim setup_nic.yml
ansible-playbook setup_nic.yml //failed

----------------------------------------------------------------------------------------------------------------------------------------------

16.3 Using Ansible to Manage IPv6

vim ipv6.yml
ansible-doc nmcli
ansible-playbook ipv6.yml //failed

----------------------------------------------------------------------------------------------------------------------------------------------


